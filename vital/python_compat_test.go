package vital

import (
	"encoding/json"
	"math"
	"os"
	"testing"
)

// GoldenData represents the structure of JSON golden files generated by Python VitalDB
type GoldenData struct {
	FileInfo GoldenFileInfo            `json:"file_info"`
	Devices  map[string]GoldenDevice   `json:"devices"`
	Tracks   map[string]GoldenTrack    `json:"tracks"`
}

type GoldenFileInfo struct {
	DtStart   float64 `json:"dt_start"`
	DtEnd     float64 `json:"dt_end"`
	GMTOffset int16   `json:"gmt_offset"`
	Duration  float64 `json:"duration"`
}

type GoldenDevice struct {
	Name     string `json:"name"`
	TypeName string `json:"type_name"`
	Port     string `json:"port"`
}

type GoldenTrack struct {
	Name         string              `json:"name"`
	Type         uint8               `json:"type"`
	Fmt          uint8               `json:"fmt"`
	Unit         string              `json:"unit"`
	SampleRate   float32             `json:"sample_rate"`
	Gain         float64             `json:"gain"`
	Offset       float64             `json:"offset"`
	MinDisplay   float32             `json:"min_display"`
	MaxDisplay   float32             `json:"max_display"`
	Color        uint32              `json:"color"`
	MonitorType  uint8               `json:"monitor_type"`
	DeviceName   string              `json:"device_name,omitempty"`
	RecordsCount int                 `json:"records_count"`
	Records      []GoldenRecord      `json:"records"`
}

type GoldenRecord struct {
	Dt  float64     `json:"dt"`
	Val interface{} `json:"val"`
}

// TestPythonCompatibility tests that Go parser produces identical results to Python VitalDB
// This is the CRITICAL test that validates the Go implementation against the golden standard.
func TestPythonCompatibility(t *testing.T) {
	testCases := []struct {
		name       string
		vitalFile  string
		goldenFile string
	}{
		{
			name:       "MICUA01_240724_180000",
			vitalFile:  "../data_sample/MICUA01_240724_180000.vital",
			goldenFile: "testdata/golden/MICUA01_240724_180000.json",
		},
		{
			name:       "MICUA01_240724_180622",
			vitalFile:  "../data_sample/MICUA01_240724_180622.vital",
			goldenFile: "testdata/golden/MICUA01_240724_180622.json",
		},
		{
			name:       "MICUA01_240724_181539",
			vitalFile:  "../data_sample/MICUA01_240724_181539.vital",
			goldenFile: "testdata/golden/MICUA01_240724_181539.json",
		},
		{
			name:       "MICUA01_240724_190000",
			vitalFile:  "../data_sample/MICUA01_240724_190000.vital",
			goldenFile: "testdata/golden/MICUA01_240724_190000.json",
		},
		{
			name:       "MICUB06_240322_230000",
			vitalFile:  "../data_sample/MICUB06_240322_230000.vital",
			goldenFile: "testdata/golden/MICUB06_240322_230000.json",
		},
		{
			name:       "MICUB08_240520_230000",
			vitalFile:  "../data_sample/MICUB08_240520_230000.vital",
			goldenFile: "testdata/golden/MICUB08_240520_230000.json",
		},
	}

	for _, tc := range testCases {
		t.Run(tc.name, func(t *testing.T) {
			// Skip if vital file doesn't exist
			if _, err := os.Stat(tc.vitalFile); os.IsNotExist(err) {
				t.Skipf("Test data file not found: %s", tc.vitalFile)
			}

			// Skip if golden file doesn't exist
			if _, err := os.Stat(tc.goldenFile); os.IsNotExist(err) {
				t.Skipf("Golden file not found: %s (run test/generate_golden_files.py)", tc.goldenFile)
			}

			// Parse with Go
			goResult, err := NewVitalFile(tc.vitalFile)
			if err != nil {
				t.Fatalf("Go parser failed: %v", err)
			}

			// Load golden file
			goldenBytes, err := os.ReadFile(tc.goldenFile)
			if err != nil {
				t.Fatalf("Failed to read golden file: %v", err)
			}

			var goldenResult GoldenData
			if err := json.Unmarshal(goldenBytes, &goldenResult); err != nil {
				t.Fatalf("Failed to unmarshal golden file: %v", err)
			}

			// Compare results
			compareFileInfo(t, goResult, goldenResult.FileInfo)
			compareDevices(t, goResult, goldenResult.Devices)
			compareTracks(t, goResult, goldenResult.Tracks)
		})
	}
}

func compareFileInfo(t *testing.T, goResult *VitalFile, golden GoldenFileInfo) {
	t.Helper()

	// Allow small floating point differences (1ms tolerance)
	const timeTolerance = 0.001

	if math.Abs(goResult.DtStart-golden.DtStart) > timeTolerance {
		t.Errorf("DtStart mismatch: got %v, want %v", goResult.DtStart, golden.DtStart)
	}

	if math.Abs(goResult.DtEnd-golden.DtEnd) > timeTolerance {
		t.Errorf("DtEnd mismatch: got %v, want %v", goResult.DtEnd, golden.DtEnd)
	}

	if goResult.Dgmt != golden.GMTOffset {
		t.Errorf("GMTOffset mismatch: got %v, want %v", goResult.Dgmt, golden.GMTOffset)
	}
}

func compareDevices(t *testing.T, goResult *VitalFile, golden map[string]GoldenDevice) {
	t.Helper()

	if len(goResult.Devs) != len(golden) {
		t.Errorf("Device count mismatch: got %d, want %d", len(goResult.Devs), len(golden))
	}

	for devName, goldenDev := range golden {
		goDev, ok := goResult.Devs[devName]
		if !ok {
			t.Errorf("Device %q not found in Go result", devName)
			continue
		}

		if goDev.Name != goldenDev.Name {
			t.Errorf("Device %q name mismatch: got %q, want %q", devName, goDev.Name, goldenDev.Name)
		}
	}
}

func compareTracks(t *testing.T, goResult *VitalFile, golden map[string]GoldenTrack) {
	t.Helper()

	if len(goResult.Trks) != len(golden) {
		t.Errorf("Track count mismatch: got %d, want %d", len(goResult.Trks), len(golden))
		// List missing tracks
		for trackName := range golden {
			if _, ok := goResult.Trks[trackName]; !ok {
				t.Errorf("  Missing track in Go result: %q", trackName)
			}
		}
		for trackName := range goResult.Trks {
			if _, ok := golden[trackName]; !ok {
				t.Errorf("  Extra track in Go result: %q", trackName)
			}
		}
	}

	for trackName, goldenTrack := range golden {
		goTrack, ok := goResult.Trks[trackName]
		if !ok {
			continue // Already reported above
		}

		// Compare track metadata
		if goTrack.Name != goldenTrack.Name {
			t.Errorf("Track %q name mismatch: got %q, want %q", trackName, goTrack.Name, goldenTrack.Name)
		}

		if goTrack.Type != goldenTrack.Type {
			t.Errorf("Track %q type mismatch: got %d, want %d", trackName, goTrack.Type, goldenTrack.Type)
		}

		if goTrack.Fmt != goldenTrack.Fmt {
			t.Errorf("Track %q fmt mismatch: got %d, want %d", trackName, goTrack.Fmt, goldenTrack.Fmt)
		}

		if goTrack.Unit != goldenTrack.Unit {
			t.Errorf("Track %q unit mismatch: got %q, want %q", trackName, goTrack.Unit, goldenTrack.Unit)
		}

		if goTrack.SRate != goldenTrack.SampleRate {
			t.Errorf("Track %q sample rate mismatch: got %v, want %v", trackName, goTrack.SRate, goldenTrack.SampleRate)
		}

		if goTrack.Gain != goldenTrack.Gain {
			t.Errorf("Track %q gain mismatch: got %v, want %v", trackName, goTrack.Gain, goldenTrack.Gain)
		}

		if goTrack.Offset != goldenTrack.Offset {
			t.Errorf("Track %q offset mismatch: got %v, want %v", trackName, goTrack.Offset, goldenTrack.Offset)
		}

		// Compare record count
		goRecCount := len(goTrack.Recs)
		if goRecCount != goldenTrack.RecordsCount {
			t.Errorf("Track %q record count mismatch: got %d, want %d", trackName, goRecCount, goldenTrack.RecordsCount)
		}

		// Compare sample records (first 100 only, as golden file has limited records)
		compareRecords(t, trackName, &goTrack, goldenTrack)
	}
}

func compareRecords(t *testing.T, trackName string, goTrack *Track, goldenTrack GoldenTrack) {
	t.Helper()

	// Only compare records that are in the golden file (first 100)
	compareCount := len(goldenTrack.Records)
	if compareCount > len(goTrack.Recs) {
		compareCount = len(goTrack.Recs)
	}

	const timeTolerance = 0.001 // 1ms tolerance

	for i := 0; i < compareCount; i++ {
		goldenRec := goldenTrack.Records[i]
		goRec := goTrack.Recs[i]

		// Compare timestamp
		if math.Abs(goRec.Dt-goldenRec.Dt) > timeTolerance {
			t.Errorf("Track %q record %d timestamp mismatch: got %v, want %v",
				trackName, i, goRec.Dt, goldenRec.Dt)
			break // Don't spam too many errors
		}

		// Compare value (type-dependent)
		compareRecordValue(t, trackName, i, goRec.Val, goldenRec.Val)
	}
}

func compareRecordValue(t *testing.T, trackName string, recIndex int, goVal, goldenVal interface{}) {
	t.Helper()

	const floatTolerance = 1e-6

	// Handle nil values
	if goldenVal == nil {
		if goVal != nil {
			t.Errorf("Track %q record %d value mismatch: got %v, want nil", trackName, recIndex, goVal)
		}
		return
	}

	// Handle arrays
	goldenArr, goldenIsArr := goldenVal.([]interface{})
	if goldenIsArr {
		// Go value should be a numeric array
		switch goArr := goVal.(type) {
		case []float32:
			compareFloat32Array(t, trackName, recIndex, goArr, goldenArr)
		case []float64:
			compareFloat64Array(t, trackName, recIndex, goArr, goldenArr)
		case []int8:
			compareInt8Array(t, trackName, recIndex, goArr, goldenArr)
		case []uint8:
			compareUint8Array(t, trackName, recIndex, goArr, goldenArr)
		case []int16:
			compareInt16Array(t, trackName, recIndex, goArr, goldenArr)
		case []uint16:
			compareUint16Array(t, trackName, recIndex, goArr, goldenArr)
		case []int32:
			compareInt32Array(t, trackName, recIndex, goArr, goldenArr)
		case []uint32:
			compareUint32Array(t, trackName, recIndex, goArr, goldenArr)
		default:
			t.Errorf("Track %q record %d: unexpected Go array type %T", trackName, recIndex, goVal)
		}
		return
	}

	// Handle single numeric values
	goldenNum, goldenIsNum := goldenVal.(float64)
	if goldenIsNum {
		goNum, ok := toFloat64(goVal)
		if !ok {
			t.Errorf("Track %q record %d: cannot convert Go value %v to float64", trackName, recIndex, goVal)
			return
		}
		if math.Abs(goNum-goldenNum) > floatTolerance {
			t.Errorf("Track %q record %d value mismatch: got %v, want %v", trackName, recIndex, goNum, goldenNum)
		}
		return
	}

	// Handle strings
	goldenStr, goldenIsStr := goldenVal.(string)
	if goldenIsStr {
		goStr, ok := goVal.(string)
		if !ok {
			t.Errorf("Track %q record %d: expected string, got %T", trackName, recIndex, goVal)
			return
		}
		if goStr != goldenStr {
			t.Errorf("Track %q record %d string mismatch: got %q, want %q", trackName, recIndex, goStr, goldenStr)
		}
		return
	}

	t.Errorf("Track %q record %d: unsupported golden value type %T", trackName, recIndex, goldenVal)
}

func compareFloat32Array(t *testing.T, trackName string, recIndex int, goArr []float32, goldenArr []interface{}) {
	t.Helper()

	if len(goArr) != len(goldenArr) {
		t.Errorf("Track %q record %d array length mismatch: got %d, want %d",
			trackName, recIndex, len(goArr), len(goldenArr))
		return
	}

	const floatTolerance = 1e-4 // Relaxed tolerance for float32

	for i := 0; i < len(goArr) && i < 10; i++ { // Check first 10 elements
		goldenVal, ok := goldenArr[i].(float64)
		if !ok {
			t.Errorf("Track %q record %d element %d: cannot convert golden value to float64", trackName, recIndex, i)
			continue
		}
		if math.Abs(float64(goArr[i])-goldenVal) > floatTolerance {
			t.Errorf("Track %q record %d element %d mismatch: got %v, want %v",
				trackName, recIndex, i, goArr[i], goldenVal)
			break
		}
	}
}

func compareFloat64Array(t *testing.T, trackName string, recIndex int, goArr []float64, goldenArr []interface{}) {
	t.Helper()

	if len(goArr) != len(goldenArr) {
		t.Errorf("Track %q record %d array length mismatch: got %d, want %d",
			trackName, recIndex, len(goArr), len(goldenArr))
		return
	}

	const floatTolerance = 1e-6

	for i := 0; i < len(goArr) && i < 10; i++ { // Check first 10 elements
		goldenVal, ok := goldenArr[i].(float64)
		if !ok {
			t.Errorf("Track %q record %d element %d: cannot convert golden value to float64", trackName, recIndex, i)
			continue
		}
		if math.Abs(goArr[i]-goldenVal) > floatTolerance {
			t.Errorf("Track %q record %d element %d mismatch: got %v, want %v",
				trackName, recIndex, i, goArr[i], goldenVal)
			break
		}
	}
}

func compareInt16Array(t *testing.T, trackName string, recIndex int, goArr []int16, goldenArr []interface{}) {
	t.Helper()

	if len(goArr) != len(goldenArr) {
		t.Errorf("Track %q record %d array length mismatch: got %d, want %d",
			trackName, recIndex, len(goArr), len(goldenArr))
		return
	}

	for i := 0; i < len(goArr) && i < 10; i++ { // Check first 10 elements
		goldenVal, ok := goldenArr[i].(float64)
		if !ok {
			t.Errorf("Track %q record %d element %d: cannot convert golden value to number", trackName, recIndex, i)
			continue
		}
		if int16(goldenVal) != goArr[i] {
			t.Errorf("Track %q record %d element %d mismatch: got %v, want %v",
				trackName, recIndex, i, goArr[i], int16(goldenVal))
			break
		}
	}
}

func toFloat64(val interface{}) (float64, bool) {
	switch v := val.(type) {
	case float64:
		return v, true
	case float32:
		return float64(v), true
	case int:
		return float64(v), true
	case int16:
		return float64(v), true
	case int32:
		return float64(v), true
	case int64:
		return float64(v), true
	case uint:
		return float64(v), true
	case uint16:
		return float64(v), true
	case uint32:
		return float64(v), true
	case uint64:
		return float64(v), true
	default:
		return 0, false
	}
}

func compareInt8Array(t *testing.T, trackName string, recIndex int, goArr []int8, goldenArr []interface{}) {
	t.Helper()

	if len(goArr) != len(goldenArr) {
		t.Errorf("Track %q record %d array length mismatch: got %d, want %d",
			trackName, recIndex, len(goArr), len(goldenArr))
		return
	}

	for i := 0; i < len(goArr) && i < 10; i++ {
		goldenVal, ok := goldenArr[i].(float64)
		if !ok {
			t.Errorf("Track %q record %d element %d: cannot convert golden value to number", trackName, recIndex, i)
			continue
		}
		if int8(goldenVal) != goArr[i] {
			t.Errorf("Track %q record %d element %d mismatch: got %v, want %v",
				trackName, recIndex, i, goArr[i], int8(goldenVal))
			break
		}
	}
}

func compareUint8Array(t *testing.T, trackName string, recIndex int, goArr []uint8, goldenArr []interface{}) {
	t.Helper()

	if len(goArr) != len(goldenArr) {
		t.Errorf("Track %q record %d array length mismatch: got %d, want %d",
			trackName, recIndex, len(goArr), len(goldenArr))
		return
	}

	for i := 0; i < len(goArr) && i < 10; i++ {
		goldenVal, ok := goldenArr[i].(float64)
		if !ok {
			t.Errorf("Track %q record %d element %d: cannot convert golden value to number", trackName, recIndex, i)
			continue
		}
		if uint8(goldenVal) != goArr[i] {
			t.Errorf("Track %q record %d element %d mismatch: got %v, want %v",
				trackName, recIndex, i, goArr[i], uint8(goldenVal))
			break
		}
	}
}

func compareUint16Array(t *testing.T, trackName string, recIndex int, goArr []uint16, goldenArr []interface{}) {
	t.Helper()

	if len(goArr) != len(goldenArr) {
		t.Errorf("Track %q record %d array length mismatch: got %d, want %d",
			trackName, recIndex, len(goArr), len(goldenArr))
		return
	}

	for i := 0; i < len(goArr) && i < 10; i++ {
		goldenVal, ok := goldenArr[i].(float64)
		if !ok {
			t.Errorf("Track %q record %d element %d: cannot convert golden value to number", trackName, recIndex, i)
			continue
		}
		if uint16(goldenVal) != goArr[i] {
			t.Errorf("Track %q record %d element %d mismatch: got %v, want %v",
				trackName, recIndex, i, goArr[i], uint16(goldenVal))
			break
		}
	}
}

func compareInt32Array(t *testing.T, trackName string, recIndex int, goArr []int32, goldenArr []interface{}) {
	t.Helper()

	if len(goArr) != len(goldenArr) {
		t.Errorf("Track %q record %d array length mismatch: got %d, want %d",
			trackName, recIndex, len(goArr), len(goldenArr))
		return
	}

	for i := 0; i < len(goArr) && i < 10; i++ {
		goldenVal, ok := goldenArr[i].(float64)
		if !ok {
			t.Errorf("Track %q record %d element %d: cannot convert golden value to number", trackName, recIndex, i)
			continue
		}
		if int32(goldenVal) != goArr[i] {
			t.Errorf("Track %q record %d element %d mismatch: got %v, want %v",
				trackName, recIndex, i, goArr[i], int32(goldenVal))
			break
		}
	}
}

func compareUint32Array(t *testing.T, trackName string, recIndex int, goArr []uint32, goldenArr []interface{}) {
	t.Helper()

	if len(goArr) != len(goldenArr) {
		t.Errorf("Track %q record %d array length mismatch: got %d, want %d",
			trackName, recIndex, len(goArr), len(goldenArr))
		return
	}

	for i := 0; i < len(goArr) && i < 10; i++ {
		goldenVal, ok := goldenArr[i].(float64)
		if !ok {
			t.Errorf("Track %q record %d element %d: cannot convert golden value to number", trackName, recIndex, i)
			continue
		}
		if uint32(goldenVal) != goArr[i] {
			t.Errorf("Track %q record %d element %d mismatch: got %v, want %v",
				trackName, recIndex, i, goArr[i], uint32(goldenVal))
			break
		}
	}
}
